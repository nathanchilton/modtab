#!/usr/bin/env ruby
require "optparse"
require "json"
require "pry-nav"

@settings = {
  harp_type: "Melody Maker G",
  operation: "letters"
}

usage = "Translates harmonica tab indicators to letters
Usage:

To process a file as input:
  tabmod --file=INPUT_FILE

To enter interactive mode:
  tabmod

To shift notes up/down:
  tabmod --shift=-3 (shifts down from C to G)

The default harp type is: Melody Maker G.
To switch to Diatonic C, use the '-d' parameter.

To transpose from one harmonica layout to another:
  tabmod -f INPUTFILE -h INPUT_LAYOUT -o OUTPUT_LAYOUT  

"

OptionParser.new { |parser|
  parser.on("-h HARP_TYPE") do |harp_type|
    @settings[:harp_type] = harp_type
  end

  parser.on("-d") do |scenario_name|
    @settings[:harp_type] = "Diatonic C"
  end

  parser.on("-o OUTPUT_LAYOUT") do |output_layout|
    @settings[:output_layout] = output_layout
  end

  parser.on("-f INPUTFILE", "--file=INPUT_FILE") do |input_file|
    @settings[:input_file] = input_file
  end

  parser.on("-s DELTA", "--shift=DELTA") do |delta|
    @settings[:shift] = delta.to_i
  end

  parser.on("--summarize") do |delta|
    @settings[:summarize] = true
  end

  parser.on("-h", "--help") do
    puts usage
    exit(0)
  end
}.parse!

def get_harp_data(harp_type)
  @lookup_table ||= JSON.parse(File.read("harptab_note_lookup.json"))
  harp_data = {}

  # binding.pry
  if @lookup_table[harp_type]
    harp_data = @lookup_table[harp_type]
  # If there wasn't an exact match, let's look for one which starts with the specified "harp_type"
  else 
    binding.pry
    matching_harps = @lookup_table.keys.select {|type| type =~ /.*#{harp_type}.*/i }
  case matching_harps.count 
  when 0
    puts "No harps were found, matching the name '#{harp_type}'"
  exit(-1)
  when 1
    harp_data = @lookup_table[matching_harps[0]]
  else
    puts "Multiple harps were found, matching the name '#{harp_type}':\n#{matching_harps.join("\n")}"
    exit(-1)
  end
end
  harp_data 
end

def find_notes_used(line)
  # binding.pry
  @notes_used ||= {}
  @note_list.each do |note|
    @notes_used[note] = true if line.include?(note)
  end
end

def fix_assumed_direction(line)
  explicit_direction = line
  (1..10).each do |i|
    explicit_direction = explicit_direction.gsub(/\s#{i}/, "+#{i}")
  end

  explicit_direction
end

def mod_line(text)
  translation = fix_assumed_direction(text)

  if @settings[:shift]

    iteration_list = @settings[:shift] > 0 ? @note_list.reverse : @note_list
    first_item = true
    iteration_list.each do |indicator|
      if first_item
        first_item = false
        next
      end
      old_value_location = @note_list.find_index(indicator)
      new_value_location = old_value_location + @settings[:shift]
      new_value =  @note_list[new_value_location] ?  @note_list[new_value_location] : "X" + (" " * (indicator.length - 1))
      translation = translation.gsub(/(#{"\\" + indicator})(?=[^'o\d]+|$)/, new_value)
    end

  elsif @settings[:output_layout]

    
    
    
    target_harp_data = get_harp_data(@settings[:output_layout])
    binding.pry
    target_note_list = target_harp_data["note_list"].keys
    
    original_tonic_note_index =  @note_list.find_index(@harp_data["tonic_notes"][0])
    target_tonic_note_index =  target_note_list.find_index(target_harp_data["tonic_notes"][0])

binding.pry

    note_pattern = /([\+\-]\d+'*)/

    translation = " -6   +6-2''-2''  +5 -2''     +4-4+5 -4"
    
    line_segments = translation.split(note_pattern)

    line_segments.each_with_index do |segment, i|
      if segment =~ note_pattern
        # find pattern in list
        # old_value_location = @note_list.find_index(indicator)

        # calculate offset from tonic note

        # find tonic note in target layout 
        # find note which is the same offset from the tonic note in the new layout
        
        
        # replace segment with note from target layout  
        line_segments[i] = '*'


      end

    end


    translation = line_segments.join
  else
    # On a diatonic harp, -2 and +3 are the same note.
    # For the sake of simplicity, we're picking one,
    # so that the list of notes can easily be shifted up/down.
    if @settings[:harp_type].downcase.include?("diatonic")
      translation = translation.gsub(/\-2[^'o]/, "+3")
    end
    @lookup_table.each_pair do |key, value|
      translation = translation.gsub(/(#{"\\" + key})(?=[^'o\d]+|$)/, value)
    end
    find_notes_used(text)
  end
# binding.pry
  translation
end

def start_tab_repl
  puts "Enter a string to translate or a blank line to quit:"

  while (line = gets.chomp).size > 0
    puts mod_line(line)
  end
end

###########################
#  Execution Starts Here  #
###########################


  # find note_list for harp_type
@harp_data = get_harp_data(@settings[:harp_type])
@note_list = @harp_data["note_list"].keys



if @settings[:input_file]
  old_path = @settings[:input_file]
  old_extension = File.extname(old_path)
  old_filename = File.basename(old_path, old_extension)
  new_filename = old_filename + "-modified" + old_extension
  new_path = File.join(File.dirname(old_path), new_filename)

  File.open(new_path, "w") do |f|
    File.readlines(old_path).each do |line|
      if /(\-|\+)\d+/.match?(line)
        f.puts mod_line(line)
        f.puts line unless @settings[:shift]
      else
        f.puts line
      end
    end
    if @settings[:summarize] && !@notes_used.empty?
      f.puts
      f.puts "Notes/Holes Used:"
      # binding.pry
      holes_used_string = ""
      @note_list.each do |hole|
        holes_used_string += " #{hole}" if @notes_used[hole]
      end

      notes_used_string = mod_line(holes_used_string)
      f.puts notes_used_string unless @settings[:shift]
      f.puts holes_used_string
    end
  end

else
  start_tab_repl
end
